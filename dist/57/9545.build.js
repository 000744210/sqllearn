(self.webpackChunksqlitelearn=self.webpackChunksqlitelearn||[]).push([[9545],{9268:function(t,n,e){(t.exports=e(9252)(!1)).push([t.id,".center-margin,.inner{margin-left:auto;margin-right:auto}.inner{max-width:600px}",""])},9545:function(t,n,e){"use strict";e.r(n),e.d(n,{default:function(){return s}});var o=e(2880),i=e(845),a={components:{DropDownBox:o.Z,TryItNow:i.Z}};var r=function(t){e(9826)},s=(0,e(2236).Z)(a,(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"inner"},[e("h1",[t._v("SQL Window Functions")]),t._v(" "),e("h2",[t._v("Introduction to SQL Window Functions")]),t._v(" "),e("p",[t._v("\n      The aggregate functions (SUM, AVG, COUNT, MIN, MAX, etc) perform\n      calculations across a set of rows and returns a single output row\n    ")]),t._v(" "),e("p",[t._v("\n      The following query uses the AVG() aggregate function to calculate the\n      average weight of all patients.\n    ")]),t._v(" "),e("try-it-now",{attrs:{code:"SELECT \n    AVG(weight) as avg_weight\nFROM\n    patients;",tryNowButton:!0}}),t._v(" "),e("p",[t._v("\n      As shown clearly in the output, all rows from the patients table are\n      grouped into a single row.\n    ")]),t._v(" "),e("p",[t._v("\n      Similar to an aggregate function, a window function calculates on a set of\n      rows. However, a window function does not cause rows to become grouped\n      into a single output row.\n    ")]),t._v(" "),e("p",[t._v("\n      The following query uses the AVG() as a window function. It returns the\n      avgerage weight of all patients along with the weight of each individual\n      patient:\n    ")]),t._v(" "),e("try-it-now",{attrs:{code:"SELECT \n    first_name,\n    last_name,\n    weight,\n    AVG(weight) OVER() as avg_weight\nFROM\n    patients;",tryNowButton:!0}}),t._v(" "),e("p",[t._v("\n      In this example, the OVER() clause signals that the AVG() function is used\n      as a window function\n    ")]),t._v(" "),e("p",[t._v("\n      The following picture illustrates the main difference between aggregate\n      functions and window functions:\n    ")]),t._v(" "),e("img",{attrs:{src:"/img/sql-window-functions.png",width:"600"}}),t._v(" "),e("h2",[t._v("SQL window function syntax")]),t._v(" "),e("p",[t._v("The syntax of the window functions is as follows:")]),t._v(" "),e("try-it-now",{attrs:{code:"window_function_name ( expression ) OVER (\n    partition_clause\n    order_clause\n    frame_clause\n)",tryNowButton:!1}}),t._v(" "),e("h3",[t._v("window_function_name")]),t._v(" "),e("p",[t._v("\n      The name of the supported window function such as ROW_NUMBER(), RANK(),\n      SUM(), and many more.\n    ")]),t._v(" "),e("h3",[t._v("expression")]),t._v(" "),e("p",[t._v("\n      The target expression or column on which the window function operates.\n    ")]),t._v(" "),e("h3",[t._v("OVER clause")]),t._v(" "),e("p",[t._v("\n      The OVER clause defines window partitions to form the groups of rows\n      specifies the orders of rows in a partition. The OVER clause consists of\n      three clauses: partition, order, and frame clauses.\n    ")]),t._v(" "),e("h3",[t._v("partition_clause")]),t._v(" "),e("p",[t._v("\n      The partition clause divides the rows into partitions to which the window\n      function applies. It has the following syntax:\n    ")]),t._v(" "),e("try-it-now",{attrs:{code:"PARTITION BY expr1, expr2, ...",tryNowButton:!1}}),t._v(" "),e("p",[t._v("\n      If the PARTITION BY clause is not specified, then the whole result set is\n      treated as a single partition.\n    ")]),t._v(" "),e("p",[t._v("\n      The order clause specifies the orders of rows in a partition on which the\n      window function operates:\n    ")]),t._v(" "),e("try-it-now",{attrs:{code:"ORDER BY \n    expression [ASC | DESC]  [NULL {FIRST| LAST}]\n    ,...",tryNowButton:!1}}),t._v(" "),e("p",[t._v("\n      A frame is the subset of the current partition. To define the frame, you\n      use one of the following syntaxes:\n    ")]),t._v(" "),e("try-it-now",{attrs:{code:"{ RANGE | ROWS } frame_start\n{ RANGE | ROWS } BETWEEN frame_start AND frame_end",tryNowButton:!1}}),t._v(" "),e("p",[t._v("where frame_start is one of the following options:")]),t._v(" "),e("try-it-now",{attrs:{code:"N PRECEDING\nUNBOUNDED PRECEDING\nCURRENT ROW",tryNowButton:!1}}),t._v(" "),e("p",[t._v("and frame_end is one of the following options:")]),t._v(" "),e("try-it-now",{attrs:{code:"CURRENT ROW\nUNBOUNDED FOLLOWING\nN FOLLOWING",tryNowButton:!1}}),t._v(" "),e("p",[t._v("The following picture illustrates a frame and its options:")]),t._v(" "),e("img",{attrs:{src:"/img/sql-window-function-frame.png",width:"600px"}}),t._v(" "),t._m(0),t._v(" "),e("p",[t._v("\n      The ROWS or RANGE specifies the type of relationship between the current\n      row and frame rows.\n    ")]),t._v(" "),t._m(1),t._v(" "),e("h2",[t._v("SQL window function types")]),t._v(" "),e("p",[t._v("\n      The window functions are divided into three types value window functions,\n      aggregation window functions, and ranking window functions:\n    ")]),t._v(" "),e("p",[t._v("Value window functions")]),t._v(" "),e("ul",[e("li",[e("modal-a",{attrs:{href:"/learn/function/first_value/"}},[t._v("FIRST_VALUE()")])],1),t._v(" "),e("li",[e("modal-a",{attrs:{href:"/learn/function/last_value/"}},[t._v("LAST_VALUE()")])],1),t._v(" "),e("li",[e("modal-a",{attrs:{href:"/learn/function/lag/"}},[t._v("LAG()")])],1),t._v(" "),e("li",[e("modal-a",{attrs:{href:"/learn/function/lead/"}},[t._v("LEAD()")])],1)]),t._v(" "),e("p",[t._v("Ranking window functions")]),t._v(" "),t._m(2),t._v(" "),e("p",[t._v("Aggregate window functions")]),t._v(" "),e("ul",[e("li",[e("modal-a",{attrs:{href:"/learn/function/avg/"}},[t._v("AVG()")])],1),t._v(" "),e("li",[e("modal-a",{attrs:{href:"/learn/function/count/"}},[t._v("COUNT()")])],1),t._v(" "),e("li",[e("modal-a",{attrs:{href:"/learn/function/max/"}},[t._v("MAX()")])],1),t._v(" "),e("li",[e("modal-a",{attrs:{href:"/learn/function/min/"}},[t._v("MIN()")])],1),t._v(" "),e("li",[e("modal-a",{attrs:{href:"/learn/function/sum/"}},[t._v("SUM()")])],1)]),t._v(" "),e("h2",[t._v("Filtering By Window Function Result")]),t._v(" "),e("p",[t._v("\n      The value of a window function can not be filtered by a where clause or a\n      having clause by default. To filter by the column you must separate the\n      results as a table using the WITH keyword.\n    ")]),t._v(" "),e("p",[t._v("\n      Lets start with a rolling sum of the weight column from the patients table\n    ")]),t._v(" "),e("try-it-now",{attrs:{code:"select\n  patient_id,\n  first_name,\n  weight,\n  sum(weight) over(order by patient_id) as rolling_sum\nfrom patients",tryNowButton:!0}}),t._v(" "),e("p",[t._v("\n      Now lets say we want to get all the patients that fall under the 1000\n      rolling_sum. We can not use the where clause as shown below:\n    ")]),t._v(" "),e("try-it-now",{attrs:{code:"-- Does not work. 'misuse of aliased window function rolling_sum'\nselect\n  patient_id,\n  first_name,\n  weight,\n  sum(weight) over(order by patient_id) as rolling_sum\nfrom patients\nwhere rolling_sum < 1000",tryNowButton:!0}}),t._v(" "),e("p",[t._v("\n      We must use the WITH keyword to separate the results as a temporary table.\n    ")]),t._v(" "),e("try-it-now",{attrs:{code:"with rolling_sum_table as (\n    select\n      patient_id,\n      first_name,\n      weight,\n      sum(weight) over(order by patient_id) as rolling_sum\n    from patients\n  )\nSELECT *\nfrom rolling_sum_table\nwhere rolling_sum < 1000",tryNowButton:!0}}),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),e("br")],1)}),[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ul",[e("li",[t._v("\n        UNBOUNDED PRECEDING: the frame starts at the first row of the partition.\n      ")]),t._v(" "),e("li",[t._v("N PRECEDING: the frame starts at Nth rows before the current row.")]),t._v(" "),e("li",[t._v("CURRENT ROW: means the current row that is being evaluated.")]),t._v(" "),e("li",[t._v("\n        UNBOUNDED FOLLOWING: the frame ends at the final row in the partition.\n      ")]),t._v(" "),e("li",[t._v("N FOLLOWING: the frame ends at the Nh row after the current row.")])])},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ul",[e("li",[t._v("\n        ROWS: the offsets of the current row and frame rows are row numbers.\n      ")]),t._v(" "),e("li",[t._v("\n        RANGE: the offset of the current row and frame rows are row values.\n      ")])])},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ul",[e("li",[t._v("CUME_DIST()")]),t._v(" "),e("li",[t._v("DENSE_RANK()")]),t._v(" "),e("li",[t._v("NTILE()")]),t._v(" "),e("li",[t._v("PERCENT_RANK()")]),t._v(" "),e("li",[t._v("RANK()")]),t._v(" "),e("li",[t._v("ROW_NUMBER()")])])}],!1,r,null,null).exports},9826:function(t,n,e){var o=e(9268);o.__esModule&&(o=o.default),"string"==typeof o&&(o=[[t.id,o,""]]),o.locals&&(t.exports=o.locals);(0,e(5346).Z)("aa99db28",o,!0,{})}}]);